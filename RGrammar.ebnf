Program                  =   { VarDefinition | FunctionDefinition } , { Block } , ReturnStatement ;
FunctionDefinition       =   FunctionDeclaration , '{' , { VarDefinition } , { Statement } , ReturnStatement , '}' ; (*Probably will forbid definition without declation*)
FunctionDeclaration      =   ReturnType , ID , '(' , [ VarDeclaration , { ',' , VarDeclaration } ] , ')' ;
VarDefinition            =   VarDeclaration , ( ( '=' , ExpressionStatement ) | ';' )  ; (*Probably will forbid definition without declation*)
VarDeclaration           =   TypeName , VariableID ;
Block                    =   '{' , { Statement } , '}' | Statement ;
Statement                =   SelectionStatement | IterationStatement | EscapeStatement | ExpressionStatement ;
SelectionStatement	     =   IfElseStatement | SwitchStatement ;
IfElseStatement		     =   IfStatement , Block , { ElseStatement , Block } ;
IfStatement		         =   'if' , '(' , Expressions , ')'  ;
ElseStatement		     =   'else' , [ IfStatement ] ;
SwitchStatement		     =   'switch' , '(' , Expression , ')' , '{' { CaseStatement } , DefaultStatement '}' ;
CaseStatement		     =   'case' , Integer , ':' , Block , BreakStatement ;
DefaultStatement         =   'default' , ':' , Block ;
IterationStatement 	     =   ForLoopStatement | DoWhileStatement | ( WhileStatement , Block ) ;
ForLoopStatement	     =   'for' , '(' , Expression , ';' , Expression , ';' , Expression , ';' , ')' , Block ;
DoWhileStatement	     =   'do' , Block , WhileStatment ;
WhileStatement           =   'while' , '(' , Expression , ')' ;
EscapeStatement          =   ContinueStatement | BreakStatement | ReturnStatement ;
ContinueStatement	     =   'continue' , ';' ;
BreakStatement		     =   'break' , ';' ;
ReturnStatement          =   'return' , ( ExpressionStatement | ';' ) ;
ExpressionStatement      =   Expression , ';' ;
Expression               =   AssignmentExpression ;
AssignmentExpression     =   [ VariableID , ( '=' | '+=' | '-=' | '*=' | '/=' | '%='  | '>>='  | '<<='  | '&='  | '|='  | '^=' ) ] , ConditionalExpression ;
ConditionalExpression    =   LogicalORExpression  , { '?' , ConditionalExpression , ':' , ConditionalExpression } ;
LogicalORExpression      =   LogicalXORExpression , { '||' , LogicalXORExpression } ;
LogicalXORExpression     =   LogicalANDExpression , { '^^' , LogicalANDExpression } ;
LogicalANDExpression     =   BitwiseORExpression , { '&&' , BitwiseORExpression } ;
BitwiseORExpression      =   BitwiseXORExpression , { '|' , BitwiseXORExpression } ;
BitwiseXORExpression     =   BitwiseANDExpression , { '^' , BitwiseANDExpression } ;
BitwiseANDExpression     =   EqualityExpression , { '&' , EqualityExpression } ;
EqualityExpression       =   RelationalExpression , { ( '==' | '!=' ) , RelationalExpression } ;
RelationalExpression     =   ShiftExpression , { ( '<' | '>' | '<=' | '>=' ) , ShiftExpression } ;
ShiftExpression          =   AdditiveExpression , { ( '<<' | '>>' ) , AdditiveExpression } ;
AdditiveExpression       =   MultiplicativeExpression , { ( '+' | '-' ) , MultiplicativeExpression } ;
MultiplicativeExpression =   UnaryExpression , { ( '*' | '/' | '%' ) , UnaryExpression } ;
UnaryExpression          =   ( ( '++' | '--' ) , VariableID ) | ( { '+' | '-' | '~' | '!' | '(' , TypeName , ')' } , PostFixExpression ) ;
PostFixExpression        =   ( VariableID , ( '++' | '--' ) ) | PrimaryExpression ;
PrimaryExpression        =   Value | Symbol | '(' , Expression , ')' | FunctionInvocation ;
Value                    =   Integer | Double | Bool | String ;         (*Parsed by the LEXER*)
Symbol                   =   Data | VariableID ;
FunctionInvocation       =   ID , '(' , [ Expression , { ',' , Expression } ] , ')' ;
Data                     =   'D' , Integer ;                                (*Parsed by the LEXER*)
VariableID               =   ID ;                                        (*Parsed by the LEXER*)
Integer                  =   \d , {\d} ;
Double                   =   \d , {\d} , '.' , \d , {\d} ;
Bool                     =   'true' | 'false' ;
String                   =   '"' , { \w } , '"' ;
ID                       =   ( ( '_' | 'a-z' | 'A-Z' ) , \w* ) ;
ReturnType               =   TypeName | 'Void' ;
TypeName                 =   'Integer' | 'Double' | 'Bool' | 'String' ;  (*Parsed by the LEXER*)